[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A propos",
    "section": "",
    "text": "Prototype d‚Äôinterface statique pour annoter des appariements.\nAuteur: Lino Galiana\nCode source sur Github"
  },
  {
    "objectID": "about.html#structure-des-donn√©es",
    "href": "about.html#structure-des-donn√©es",
    "title": "A propos",
    "section": "Structure des donn√©es",
    "text": "Structure des donn√©es\nL‚Äôobjectif est que cet outil soit flexible, il comporte donc un nombre de contraintes minimales √† son utilisateur. Celles-ci sont principalement les suivantes:\n\nLe fichier doit √™tre au format csv avec des s√©parateurs , ;\nLes colonnes permettant de comparer les paires sont identifi√©es par des suffixes. Elles peuvent √™tre plus nombreuses que dans les exemples sur la page, il n‚Äôy a pas de contrainte sur le nombre de colonnes √† comparer (tant qu‚Äôil y en a au moins une).\n\n\ndb = DuckDBClient.of({\n  example: FileAttachment(\"example.csv\"),\n  example2: FileAttachment(\"example2.csv\")\n})\n\n\n\n\n\n\n\n1. Comparaison des paires\nPour la page de comparaison des paires, le suffixe attendu pour dissocier les paires est _query (pour la paire servant de benchmark) ou _match (pour la paire candidate).\nVoici un exemple de donn√©es respectant cette contrainte:\n\nInputs.table(\n    db.sql`SELECT * FROM example`\n)\n\n\n\n\n\n\n\n\n2. Choix entre plusieurs algorithmes\nPour la page de comparaison des algorithmes, le suffixe attendu pour dissocier les paires est _query (pour la paire servant de benchmark), _match1 (pour la premi√®re paire candidate) ou _match2 (pour la deuxi√®me paire candidate).\nVoici un exemple de donn√©es respectant cette contrainte:\n\nInputs.table(\n    db.sql`SELECT * FROM example2`\n)"
  },
  {
    "objectID": "pairs.html",
    "href": "pairs.html",
    "title": "Annotation de paires",
    "section": "",
    "text": "d3 = require(await FileAttachment('/js/d3.min.js').url())\n\n\n\n\n\n\n\ninputs = require(await FileAttachment('/js/inputs.min.js').url())\n\n\n\n\n\n\n\nmarked = require(await FileAttachment('/js/marked.min.js').url())\n\n\n\n\n\n\n\nhtl = require(await FileAttachment('/js/htl.min.js').url())\n\n\n\n\n\n\n\nhtml`&lt;div name=\"file-import\"&gt;${viewof csvfile}&lt;/div&gt;`\n\n\n\n\n\n\n\nhtml`&lt;div name=\"colonnes-print\"&gt;${viewof columns_to_show}&lt;/div&gt;`\n\n\n\n\n\n\n\n// Now create the grid_two_dataframes template literal\ngrid_two_dataframes = await html`\n  &lt;div style=\"\n    background: #fff;\n    margin: 0;\n    border: none;\n    display: grid;\n    width: ${screen.width};\n    grid-template-areas: \n      'a b'\n      'c c'\n      'f d'\n      'g g'\n      'h h'\n      'i i'\n      'e e'\n      ;\n    grid-gap: 10px;\n  \"&gt;\n    &lt;div name=\"a\" style=\"grid-area: a; position: relative;\"&gt;${viewof tt1}&lt;/div&gt;\n    &lt;div name=\"b\" style=\"grid-area: b; position: relative;\"&gt;${viewof tt2}&lt;/div&gt;\n    &lt;div name=\"c\" style=\"grid-area: c; position: relative;\"&gt;${viewof decision}&lt;/div&gt;\n    &lt;div name=\"f\" style=\"grid-area: f; position: relative;\"&gt;${viewof text_input}&lt;/div&gt;\n    &lt;div name=\"d\" style=\"grid-area: d; position: relative;\"&gt;${count_printed}&lt;/div&gt;\n    &lt;div name=\"g\" style=\"grid-area: g; position: relative;\"&gt;${message_share}&lt;/div&gt;\n    &lt;div name=\"h\" style=\"grid-area: h; position: relative;\"&gt;${progress}&lt;/div&gt;\n    &lt;div name=\"i\" style=\"grid-area: i; position: relative;\"&gt;${message_final}&lt;/div&gt;\n    &lt;div name=\"e\" style=\"grid-area: e; position: relative;\"&gt;${viewof download}&lt;/div&gt;\n  &lt;/div&gt;\n`;\n\n\n\n\n\n\n\nmessage_share = {\n  if (share &lt; 10){\n    return md`Vous avez annot√© ${share}% des paires du fichier d'entr√©e`\n  } else {\n    return md`Bravo vous avez annot√© ${share}% des paires du fichier d'entr√©e`\n  }\n}\n\n\n\n\n\n\n\nprogress = {\n  const width = 360;\n  const height = 20;\n  const context = DOM.context2d(width, height);\n  context.canvas.style.border = \"solid 1px black\";\n  const i = width*(share/100);\n  context.clearRect(0, 0, width, height);\n  context.fillStyle = 'green'\n  context.fillRect(0, 0, i, height);\n  yield context.canvas;\n}\n\n\n\n\n\n\n\nmessage_final = {\n  if (share === 100){\n    return md`__Vous avez annot√© l'ensemble de votre fichier üí™üéâ__`\n  } else {\n    return md``\n  }\n}\n\n\n\n\n\n\n\nmd`${max_count} Annotation${max_count&gt;1 ? 's' : ''}`\n\n\n\n\n\n\n\n\ndb = DuckDBClient.of({\n  match : await csvfile.csv()\n})\n\n\n\n\n\n\n\ntable_names = db.sql`SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'match'`\ncolumn_names = table_names.flatMap(item =&gt; item.column_name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndf = db.sql`SELECT * FROM match`\ndf_query = db.query(\n  `SELECT ${columns_to_show.map(l =&gt; l + \"_query\").join(', ')} FROM match`\n)\ndf_match = db.query(\n  `SELECT ${columns_to_show.map(l =&gt; l + \"_match\").join(', ')} FROM match`\n)\nn_rows_sql = db.sql`SELECT COUNT(*) AS COUNT FROM match`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn_rows = n_rows_sql[0]['COUNT']\nmax_count = Math.min(Number(n_rows),count)\ncurrent_row = Math.min(Number(n_rows)-1,count)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunique_columns_dup = column_names.map(columnName =&gt; columnName.replace(\"_query\", \"\").replace(\"_match\", \"\"));\nunique_columns = Array.from(new Set(unique_columns_dup))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof csvfile = Inputs.file({label: md`__Fichier √† annoter__ üìÅ ([Exemple ici](https://raw.githubusercontent.com/linogaliana/serverless-annotation-tool/master/example.csv))`, accept: \".csv\", required: true})\n\n\n\n\n\n\n\n\nviewof columns_to_show = Inputs.checkbox(\n  unique_columns,\n  {label: \"Colonnes √† afficher\", value: unique_columns, format: d =&gt; d.replace(\"_\", \" \").capitalize()})\n\n\n\n\n\n\n\n\nshare = Math.round(100*max_count/Number(n_rows))\n\n\n\n\n\n\n\n\nviewof filename_input = Inputs.text(\n    {\n      label: html`&lt;b&gt;Nom du fichier pour l'export&lt;/b&gt;üìÅ`,\n      placeholder: \"annotations.json\",\n      value: \"annotations.json\"  \n      }\n)\n\n\n\n\n\n\n\nfunction serialize (data) {\n let s = JSON.stringify(data);\n return new Blob([s], {type: \"application/json\"}) \n}\n\n\n\n\n\n\n\nviewof download = DOM.download(serialize(x), filename_input.replace(\".json\", \"\"), \"Sauvegarder les annotations üëá dans un fichier\")\n\n\n\n\n\n\n\n\nviewof text_input = (count,\n  Inputs.text(\n    {label: html`&lt;b&gt;Raison de la d√©cision&lt;/b&gt;`,\n    //disabled: decision == null,\n    placeholder: \"Un texte explicatif\"})\n)\n\n\n\n\n\n\n\ndecision_label = [\n  {text: \"Accepter üëçÔ∏è\", color: \"green\", decision: \"Accepted\"},\n  {text: \"Rejeter üëéÔ∏è\", color: \"red\", decision: \"Rejected\"},\n  null\n]\n\n\n\n\n\n\n\nviewof decision = (count, Inputs.radio(\n  decision_label,\n  {label: \"D√©cision\",\n   format: x =&gt; (x == null) ? html`&lt;span style=\"border-bottom: solid 2px blue; margin-bottom: -2px;\"&gt;D√©cision √† prendre ü§î` : html`&lt;span style=\"text-transform: capitalize; border-bottom: solid 2px ${x.color}; margin-bottom: -2px;\"&gt;${x.text}`,\n   value: null\n  }\n))\n\n\n\n\n\n\n\nviewof count = Inputs.button(\"Valider !\")\n\n\n\n\n\n\n\nviewof count_disabled = Inputs.button(\"Faire un choix pour pouvoir valider !\", {disabled : true})\n\n\n\n\n\n\n\n\n\n\nfunction reshape_row(row) {\n  return Object.entries(row).map(([column, value]) =&gt; ({ column, value }));\n}\n\n\n\n\n\n\n\nfunction color_accepted(d) {\n  const backgroundColor = d === \"Accepted\" ? \"#5f9c5f\" : \"#fc4747\";\n  return html`&lt;div style=\"background: ${backgroundColor};text-align:right;padding:2px 5px;\"&gt;${d}&lt;/div&gt;`;\n}\n\n\n\n\n\n\n\nfunction create_color_mapping(array_left, array_right) {\n  const mapping = {};\n  array_left.forEach((obj1, index) =&gt; {\n    const obj2 = array_right[index];\n    const key = obj1.value; // Use obj1.value as the key\n\n    if (obj1.value === obj2.value) {\n      mapping[key] = \"#5f9c5f\";\n    } else {\n      mapping[key] = \"#fc4747\";\n    }\n  });\n  return mapping\n}\n\nfunction create_color_map(key, array) {\n  const value = array[key];\n  const backgroundColor = value ;\n  return html`&lt;div style=\"background: ${backgroundColor};text-align:right;padding:2px 5px;\"&gt;${key}&lt;/div&gt;`;\n}\nfunction create_variable_row(d){\n  const d_nice = d.replace(\"_query\", \"\").capitalize().replace(\"_\", \" \") ;\n  return html`&lt;b&gt;${d_nice}&lt;/b&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction table_pairs(array, color_scale, header, columns) {\n  const tt = Inputs.table(\n  array,\n    {\n    format: {\n      \"value\": d =&gt; create_color_map(d, color_scale),\n      \"column\": d =&gt; create_variable_row(d)\n      },\n    header: header,\n    columns: columns\n    }\n  ) ;\n  return tt\n}\n\n\n\n\n\n\n\n\nObject.defineProperty(String.prototype, 'capitalize', {\n  value: function() {\n    return this.charAt(0).toUpperCase() + this.slice(1);\n  },\n  enumerable: false\n});\n\n\n\n\n\n\n\n\n\narray1 = reshape_row(df_query[current_row])\narray2 = reshape_row(df_match[current_row])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncolors_data1 = create_color_mapping(array1, array2)\ncolors_data2 = create_color_mapping(array2, array1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof tt1 = table_pairs(\n  array1, colors_data1, \n  {\"value\": \"Valeur observ√©e\", \"column\": \"Variable d'int√©r√™t\"},\n  [\"column\", \"value\"]\n)\n\n\n\n\n\n\n\nviewof tt2 = table_pairs(\n  array2, colors_data2, \n   {\"value\": \"Paire potentielle\"},\n   [\"value\"]\n)\n\n\n\n\n\n\n\n\nviewof final_table = Inputs.table(\n  x,\n  {format: {\n      \"similarity\": d =&gt; color_accepted(d)\n  }\n  })\n\n\n\n\n\n\n\n\nd = [];\nfunction push_mutable(d){\n  if (decision !== null) {\n    if (d.some(element =&gt; element.count === current_row)){\n      const index_replace = d.findIndex(element =&gt; element.count === current_row);\n      d[index_replace] = d_row ;\n    } else{\n      d.push(d_row);\n    }\n    }\n  return d ;\n}\nx = push_mutable(d)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd_row = {\n  // Assuming `count` and `data_pairs` are already defined\n  const newElement = { ...df[current_row] }; // Create a shallow copy of the original element\n\n  if (decision !== null) {\n    newElement.similarity = decision.decision; // Update the \"field\" property with the value of `decision.decision`\n    newElement.justification = \"no decision yet\" ;\n    newElement.count = current_row ;\n  } else {\n    newElement.count = current_row ;\n    newElement.similarity = \"no decision yet\"; // Set the \"field\" property to \"nothing\" if `decision.decision` is null\n    //newElement.justification = text_input ;\n  }\n\n  return newElement;\n}\n\n\n\n\n\n\n\n{\n  if (x[current_row]) {\n    x[current_row].justification = text_input ;\n  }\n}\n\n\n\n\n\n\n\ncount_printed = {\n  // Define a variable to hold the content of the 'd' div\n  let countDivContent;\n\n  // Check if 'decision' is null or not and set the 'countDivContent' accordingly\n  if (decision === null) {\n    countDivContent = viewof count_disabled;\n  } else {\n    countDivContent = viewof count;\n  }\n  return countDivContent\n}\n\n\n\n\n\n\n\ncount_hidden = {\n  // Define a variable to hold the content of the 'd' div\n  let countDivContent;\n\n  // Check if 'decision' is null or not and set the 'countDivContent' accordingly\n  if (decision === null) {\n    countDivContent = viewof count;\n  } else {\n    countDivContent = viewof count_disabled;\n  }\n  return countDivContent\n}\n\n\n\n\n\n\n\nhtml`&lt;div style=\"display: none;\"&gt;${count_hidden}&lt;/div&gt;`"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Interface d‚Äôannotation d‚Äôappariements",
    "section": "",
    "text": "Annotation de paires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoix entre plusieurs algorithmes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "multiple.html",
    "href": "multiple.html",
    "title": "Choix entre plusieurs algorithmes",
    "section": "",
    "text": "html`&lt;div name=\"file-import\"&gt;${viewof csvfile}&lt;/div&gt;`\n\n\n\n\n\n\n\nhtml`&lt;div name=\"colonnes-print\"&gt;${viewof columns_to_show}&lt;/div&gt;`\n\n\n\n\n\n\n\ngrid_two_dataframes = await html`&lt;div style=\"\n              background: #fff;\n              margin: 0;\n              border: none ;\n              display: grid;\n              width: ${screen.width};\n              grid-template-areas: \n                'a b c'\n                'g g g'\n                'd d d'\n                'f f f'\n                'e e e'\n                ;\n              grid-gap: 10px;\n            \"&gt;\n              &lt;div name=\"a\" style=\"grid-area: a; position: relative;\"&gt;${viewof tt1}&lt;/div&gt;\n              &lt;div name=\"b\" style=\"grid-area: b; position: relative;\"&gt;${viewof tt2}&lt;/div&gt;\n              &lt;div name=\"c\" style=\"grid-area: c; position: relative;\"&gt;${viewof tt3}&lt;/div&gt;\n              &lt;div name=\"g\" style=\"grid-area: g; position: relative;\"&gt;${viewof decision}&lt;/div&gt;\n              &lt;div name=\"d\" style=\"grid-area: d; position: relative;\"&gt;${count_printed}&lt;/div&gt;\n              &lt;div name=\"f\" style=\"grid-area: f; position: relative;\"&gt;${viewof text_input}&lt;/div&gt;\n            &lt;/div&gt;`\n\n\n\n\n\n\n\nviewof count = Inputs.button(\"Valider !\")\n\n\n\n\n\n\n\nviewof count_disabled = Inputs.button(\"Faire un choix pour pouvoir valider !\", {disabled : true})\n\n\n\n\n\n\n\nmessage_share = {\n  if (share &lt; 10){\n    return md`Vous avez annot√© ${share}% des paires du fichier d'entr√©e`\n  } else {\n    return md`Bravo vous avez annot√© ${share}% des paires du fichier d'entr√©e`\n  }\n}\n\n\n\n\n\n\n\nprogress = {\n  const width = 360;\n  const height = 20;\n  const context = DOM.context2d(width, height);\n  context.canvas.style.border = \"solid 1px black\";\n  const i = width*(share/100);\n  context.clearRect(0, 0, width, height);\n  context.fillStyle = 'green'\n  context.fillRect(0, 0, i, height);\n  yield context.canvas;\n}\n\n\n\n\n\n\n\nmessage_final = {\n  if (share === 100){\n    return md`__Vous avez annot√© l'ensemble de votre fichier üí™üéâ__`\n  } else {\n    return md``\n  }\n}\n\n\n\n\n\n\n\nmd`${max_count} Annotation${max_count&gt;1 ? 's' : ''}`\n\n\n\n\n\n\n\n\nviewof text_input = (count,\n  Inputs.text(\n    {label: html`&lt;b&gt;Raison de la d√©cision&lt;/b&gt;`,\n    //disabled: decision == null,\n    placeholder: \"Un texte explicatif\"})\n)\n\n\n\n\n\n\n\ndecision_label = [\n  {text: \"Accepter n¬∞1 üëçÔ∏è\", color: \"green\", decision: \"Accepted 1\"},\n  {text: \"Accepter n¬∞2 üëçÔ∏è\", color: \"green\", decision: \"Accepted 2\"},\n  {text: \"Accepter les deux üëçÔ∏èüëçÔ∏è\", color: \"green\", decision: \"Both accepted\"},\n  {text: \"Rejeter les deux üëéÔ∏è\", color: \"red\", decision: \"Rejected\"},\n  null\n]\n\n\n\n\n\n\n\nviewof decision = (count, Inputs.radio(\n  decision_label,\n  {label: \"D√©cision\",\n   format: x =&gt; (x == null) ? html`&lt;span style=\"border-bottom: solid 2px blue; margin-bottom: -2px;\"&gt;D√©cision √† prendre ü§î` : html`&lt;span style=\"text-transform: capitalize; border-bottom: solid 2px ${x.color}; margin-bottom: -2px;\"&gt;${x.text}`,\n   value: null\n  }\n))\n\n\n\n\n\n\n\n\n\n\nfunction reshape_row(row) {\n  return Object.entries(row).map(([column, value]) =&gt; ({ column, value }));\n}\n\n\n\n\n\n\n\nfunction color_accepted(d) {\n  const backgroundColor = d === \"Accepted\" ? \"#5f9c5f\" : \"#fc4747\";\n  return html`&lt;div style=\"background: ${backgroundColor};text-align:right;padding:2px 5px;\"&gt;${d}&lt;/div&gt;`;\n}\n\n\n\n\n\n\n\nfunction create_color_mapping(array_left, array_right) {\n  const mapping = {};\n  array_left.forEach((obj1, index) =&gt; {\n    const obj2 = array_right[index];\n    const key = obj1.value; // Use obj1.value as the key\n\n    if (obj1.value === obj2.value) {\n      mapping[key] = \"#5f9c5f\";\n    } else {\n      mapping[key] = \"#fc4747\";\n    }\n  });\n  return mapping\n}\n\nfunction create_color_map(key, array) {\n  const value = array[key];\n  const backgroundColor = value ;\n  return html`&lt;div style=\"background: ${backgroundColor};text-align:right;padding:2px 5px;\"&gt;${key}&lt;/div&gt;`;\n}\nfunction create_variable_row(d){\n  const d_nice = d.replace(\"_query\", \"\").capitalize().replace(\"_\", \" \") ;\n  return html`&lt;b&gt;${d_nice}&lt;/b&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction table_pairs(array, color_scale, header, columns) {\n  const tt = Inputs.table(\n  array,\n    {\n    format: {\n      \"value\": d =&gt; create_color_map(d, color_scale),\n      \"column\": d =&gt; create_variable_row(d)\n      },\n    header: header,\n    columns: columns\n    }\n  ) ;\n  return tt\n}\n\n\n\n\n\n\n\n\nObject.defineProperty(String.prototype, 'capitalize', {\n  value: function() {\n    return this.charAt(0).toUpperCase() + this.slice(1);\n  },\n  enumerable: false\n});\n\n\n\n\n\n\n\n\n\narray1 = reshape_row(df_query[current_row])\narray2 = reshape_row(df_match1[current_row])\narray3 = reshape_row(df_match2[current_row])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncolors_data1 = create_color_mapping(array1, array1)\ncolors_data2 = create_color_mapping(array2, array1)\ncolors_data3 = create_color_mapping(array3, array1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof tt1 = table_pairs(\n  array1, colors_data1, \n  {\"value\": \"Valeur observ√©e\", \"column\": \"Variable d'int√©r√™t\"},\n  [\"column\", \"value\"]\n)\n\n\n\n\n\n\n\nviewof tt2 = table_pairs(\n  array2, colors_data2, \n   {\"value\": \"Paire potentielle n¬∞1\"},\n   [\"value\"]\n)\n\n\n\n\n\n\n\nviewof tt3 = table_pairs(\n  array3, colors_data3, \n   {\"value\": \"Paire potentielle n¬∞2\"},\n   [\"value\"]\n)\n\n\n\n\n\n\n\n\nviewof filename_input = Inputs.text(\n    {\n      label: html`&lt;b&gt;Nom du fichier pour l'export&lt;/b&gt;üìÅ`,\n      placeholder: \"annotations.json\",\n      value: \"annotations.json\"  \n      }\n)\n\n\n\n\n\n\n\nfunction serialize (data) {\n let s = JSON.stringify(data);\n return new Blob([s], {type: \"application/json\"}) \n}\n\n\n\n\n\n\n\nviewof download = DOM.download(serialize(x), filename_input.replace(\".json\", \"\"), \"Sauvegarder les annotations üëá dans un fichier\")\n\n\n\n\n\n\n\n\ndb = DuckDBClient.of({\n  match : await csvfile.csv()\n})\n\n\n\n\n\n\n\ntable_names = db.sql`SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'match'`\ncolumn_names = table_names.flatMap(item =&gt; item.column_name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndf = db.sql`SELECT * FROM match`\ndf_query = db.query(\n  `SELECT ${columns_to_show.map(l =&gt; l + \"_query\").join(', ')} FROM match`\n)\ndf_match1 = db.query(\n  `SELECT ${columns_to_show.map(l =&gt; l + \"_match1\").join(', ')} FROM match`\n)\ndf_match2 = db.query(\n  `SELECT ${columns_to_show.map(l =&gt; l + \"_match2\").join(', ')} FROM match`\n)\nn_rows_sql = db.sql`SELECT COUNT(*) AS COUNT FROM match`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn_rows = n_rows_sql[0]['COUNT']\nmax_count = Math.min(Number(n_rows),count)\ncurrent_row = Math.min(Number(n_rows)-1,count)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunique_columns_dup = column_names.map(columnName =&gt; columnName.replace(\"_query\", \"\").replace(\"_match1\", \"\").replace(\"_match2\", \"\"));\nunique_columns = Array.from(new Set(unique_columns_dup))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshare = Math.round(100*max_count/Number(n_rows))\n\n\n\n\n\n\n\n\nviewof csvfile = Inputs.file({label: md`__Fichier √† annoter__ üìÅ ([Exemple ici](https://raw.githubusercontent.com/linogaliana/serverless-annotation-tool/master/example2.csv))`, accept: \".csv\", required: true})\n\n\n\n\n\n\n\n\nviewof columns_to_show = Inputs.checkbox(\n  unique_columns,\n  {label: \"Colonnes √† afficher\", value: unique_columns, format: d =&gt; d.replace(\"_\", \" \").capitalize()})\n\n\n\n\n\n\n\n\nd = [];\nfunction push_mutable(d){\n  if (decision !== null) {\n    if (d.some(element =&gt; element.count === current_row)){\n      const index_replace = d.findIndex(element =&gt; element.count === current_row);\n      d[index_replace] = d_row ;\n    } else{\n      d.push(d_row);\n    }\n    }\n  return d ;\n}\nx = push_mutable(d)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd_row = {\n  // Assuming `count` and `data_pairs` are already defined\n  const newElement = { ...df[current_row] }; // Create a shallow copy of the original element\n\n  if (decision !== null) {\n    newElement.similarity = decision.decision; // Update the \"field\" property with the value of `decision.decision`\n    newElement.justification = \"no decision yet\" ;\n    newElement.count = current_row ;\n  } else {\n    newElement.count = current_row ;\n    newElement.similarity = \"no decision yet\"; // Set the \"field\" property to \"nothing\" if `decision.decision` is null\n    //newElement.justification = text_input ;\n  }\n\n  return newElement;\n}\n\n\n\n\n\n\n\n{\n  if (x[current_row]) {\n    x[current_row].justification = text_input ;\n  }\n}\n\n\n\n\n\n\n\n\nviewof final_table = Inputs.table(\n  x\n)\n\n\n\n\n\n\n\n\ncount_printed = {\n  // Define a variable to hold the content of the 'd' div\n  let countDivContent;\n\n  // Check if 'decision' is null or not and set the 'countDivContent' accordingly\n  if (decision === null) {\n    countDivContent = viewof count_disabled;\n  } else {\n    countDivContent = viewof count;\n  }\n  return countDivContent\n}\n\n\n\n\n\n\n\ncount_hidden = {\n  // Define a variable to hold the content of the 'd' div\n  let countDivContent;\n\n  // Check if 'decision' is null or not and set the 'countDivContent' accordingly\n  if (decision === null) {\n    countDivContent = viewof count;\n  } else {\n    countDivContent = viewof count_disabled;\n  }\n  return countDivContent\n}\n\n\n\n\n\n\n\nhtml`&lt;div style=\"display: none;\"&gt;${count_hidden}&lt;/div&gt;`"
  }
]