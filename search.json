[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Annotation de fichiers",
    "section": "",
    "text": "grid_two_dataframes = html`&lt;div style=\"\n            background: #fff;\n            margin: 0;\n            border: none ;\n            display: grid;\n            width: ${screen.width};\n            grid-template-areas: \n              'a b'\n              'c c'\n              'd d'\n              'e e';\n            grid-gap: 10px;\n          \"&gt;\n            &lt;div name=\"a\" style=\"grid-area: a; position: relative;\"&gt;${viewof tt1}&lt;/div&gt;\n            &lt;div name=\"b\" style=\"grid-area: b; position: relative;\"&gt;${viewof tt2}&lt;/div&gt;\n            &lt;div name=\"c\" style=\"grid-area: c; position: relative;\"&gt;${viewof decision}&lt;/div&gt;\n            &lt;div name=\"d\" style=\"grid-area: d; position: relative;\"&gt;${viewof count}&lt;/div&gt;\n            &lt;div name=\"e\" style=\"grid-area: e; position: relative;\"&gt;${viewof download}&lt;/div&gt;\n          &lt;/div&gt;`\n\n\n\n\n\n\n\nviewof download = DOM.download(serialize(d), null, \"Sauvegarder les annotations dans un fichier\")\n\n\n\n\n\n\n\nviewof tt1 = Inputs.table(\n  df_query[count],\n  {\n    columns: \"1\",\n    header: {\"1\": \"Observation\"}\n  }\n)\n\n\n\n\n\n\n\nviewof tt2 = Inputs.table(\n  df_match[count],\n  {\n    columns: \"1\",\n    header: {\"1\": \"Paire potentielle\"}\n  }\n)\n\n\n\n\n\n\n\nurl_file = \"https://raw.githubusercontent.com/J535D165/recordlinkage-annotator/master/examples/annotation_dishonesty.json\"\ndata_pairs = d3.json(\n  url_file\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndecision_label = [\n  {text: \"Accepter üëçÔ∏è\", color: \"green\", decision: \"Accepted\"},\n  {text: \"Rejeter üëéÔ∏è\", color: \"red\", decision: \"Rejected\"},\n  null\n]\n\n\n\n\n\n\n\nviewof decision = (count, Inputs.radio(\n  decision_label,\n  {label: \"D√©cision\",\n   format: x =&gt; (x == null) ? html`&lt;span style=\"border-bottom: solid 2px blue; margin-bottom: -2px;\"&gt;D√©cision √† prendre ü§î` : html`&lt;span style=\"text-transform: capitalize; border-bottom: solid 2px ${x.color}; margin-bottom: -2px;\"&gt;${x.text}`,\n   value: null\n  }\n))\n\n\n\n\n\n\n\nviewof count = Inputs.button(\"Nouvel exemple √† annoter !\")\n\n\n\n\n\n\n\nd = {\n  // Assuming `count` and `data_pairs` are already defined\nconst newElement = { ...df[count] }; // Create a shallow copy of the original element\n\nif (decision !== null) {\n  newElement.similarity = decision.decision; // Update the \"field\" property with the value of `decision.decision`\n} else {\n  newElement.similarity = \"no decision yet\"; // Set the \"field\" property to \"nothing\" if `decision.decision` is null\n}\n\n  return newElement;\n}\n\n\n\n\n\n\n\nfunction serialize (data) {\n let s = JSON.stringify(data);\n return new Blob([s], {type: \"application/json\"}) \n}\n\n\n\n\n\n\n\ndb = DuckDBClient.of({\n  match : await FileAttachment(\"example.csv\")\n})\n\n\n\n\n\n\n\ntable_names = db.sql`SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'match'`\ncolumn_names = table_names.flatMap(item =&gt; item.column_name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndf = db.sql`SELECT * FROM match`\ndf_query = db.query(\n  `SELECT ${unique_columns.map(l =&gt; l + \"_query\").join(', ')} FROM match`\n)\ndf_match = db.query(\n  `SELECT ${unique_columns.map(l =&gt; l + \"_match\").join(', ')} FROM match`\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nunique_columns_dup = column_names.map(columnName =&gt; columnName.replace(\"_query\", \"\").replace(\"_match\", \"\"));\nunique_columns = Array.from(new Set(unique_columns_dup))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A propos",
    "section": "",
    "text": "Prototype de site r√©actif pour annoter des paires d‚Äôappariement"
  }
]