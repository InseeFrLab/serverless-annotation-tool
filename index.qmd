---
title: "Annotation de fichiers"
echo: false
---

```{ojs}
viewof columns_to_show = Inputs.checkbox(unique_columns, {label: "Colonnes à afficher", value: unique_columns})
```


```{ojs}
//| echo: false
grid_two_dataframes = html`<div style="
            background: #fff;
            margin: 0;
            border: none ;
            display: grid;
            width: ${screen.width};
            grid-template-areas: 
              'a b'
              'c c'
              'd d'
              'e e';
            grid-gap: 10px;
          ">
            <div name="a" style="grid-area: a; position: relative;">${viewof tt1}</div>
            <div name="b" style="grid-area: b; position: relative;">${viewof tt2}</div>
            <div name="c" style="grid-area: c; position: relative;">${viewof decision}</div>
            <div name="d" style="grid-area: d; position: relative;">${viewof count}</div>
            <div name="e" style="grid-area: e; position: relative;">${viewof download}</div>
          </div>`
```


```{ojs}
//| echo: false
viewof download = DOM.download(serialize(d), null, "Sauvegarder les annotations 👇 dans un fichier")
```

```{ojs}
array1 = reshape_row(df_query[count])
array2 = reshape_row(df_match[count])

function create_color_mapping(array1, array2) {
  const mapping = {};
  array1.forEach((obj1, index) => {
    const obj2 = array2[index];
    const key = obj1.value; // Use obj1.value as the key

    if (obj1.value === obj2.value) {
      mapping[key] = "green";
    } else {
      mapping[key] = "red";
    }
  });
  return mapping
}

function create_color_map(key, array1) {
  const value = array1[key];
  const backgroundColor = value ;
  return html`<div style="background: ${backgroundColor}">${key}</div>`;
}


colors_data1 = create_color_mapping(array1, array2)
colors_data2 = create_color_mapping(array2, array1)
```


```{ojs}
viewof tt1 = Inputs.table(
  reshape_row(
    df_query[count]
  ),
    {
    format: {"value": d => create_color_map(d, colors_data1) },
    header: {"value": "Valeur observée"}
  }
)
```

```{ojs}
viewof tt2 = Inputs.table(
  reshape_row(df_match[count]),
  {
    columns: ["value"],
    format: {"value": d => create_color_map(d, colors_data2) },
    header: {"value": "Paire potentielle"}
  }
)
```

```{ojs}
url_file = "https://raw.githubusercontent.com/J535D165/recordlinkage-annotator/master/examples/annotation_dishonesty.json"
data_pairs = d3.json(
  url_file
)
```

```{ojs}
decision_label = [
  {text: "Accepter 👍️", color: "green", decision: "Accepted"},
  {text: "Rejeter 👎️", color: "red", decision: "Rejected"},
  null
]
```

```{ojs}
viewof decision = (count, Inputs.radio(
  decision_label,
  {label: "Décision",
   format: x => (x == null) ? html`<span style="border-bottom: solid 2px blue; margin-bottom: -2px;">Décision à prendre 🤔` : html`<span style="text-transform: capitalize; border-bottom: solid 2px ${x.color}; margin-bottom: -2px;">${x.text}`,
   value: null
  }
))
```


```{ojs}
viewof count = Inputs.button("Nouvel exemple à annoter !")
```

Annotations:

```{ojs}
Inputs.table(x)
```

```{ojs}
d = [];
```

```{ojs}
function push_mutable(d){
  if (decision !== null) {
      d.push(d_row);
    }
  return d ;
}
x = push_mutable(d)
```


```{ojs}
d_row = {
  // Assuming `count` and `data_pairs` are already defined
  const newElement = { ...df[count] }; // Create a shallow copy of the original element

  if (decision !== null) {
    newElement.similarity = decision.decision; // Update the "field" property with the value of `decision.decision`
  } else {
    newElement.similarity = "no decision yet"; // Set the "field" property to "nothing" if `decision.decision` is null
  }

  return newElement;
}
```

```{ojs}
function serialize (data) {
 let s = JSON.stringify(data);
 return new Blob([s], {type: "application/json"}) 
}
```


```{ojs}
db = DuckDBClient.of({
  match : await FileAttachment("example.csv")
})
```

```{ojs}
table_names = db.sql`SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'match'`
column_names = table_names.flatMap(item => item.column_name)
```

```{ojs}
df = db.sql`SELECT * FROM match`
df_query = db.query(
  `SELECT ${columns_to_show.map(l => l + "_query").join(', ')} FROM match`
)
df_match = db.query(
  `SELECT ${columns_to_show.map(l => l + "_match").join(', ')} FROM match`
)
```

```{ojs}
unique_columns_dup = column_names.map(columnName => columnName.replace("_query", "").replace("_match", ""));
unique_columns = Array.from(new Set(unique_columns_dup))
```



```{ojs}
function reshape_row(row) {
  return Object.entries(row).map(([column, value]) => ({ column, value }));
}
```
